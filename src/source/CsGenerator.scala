package djinni

import djinni.ast._
import djinni.generatorTools._
import djinni.meta._
import djinni.writer.IndentWriter

import scala.collection.mutable

class CsGenerator(spec: Spec) extends Generator(spec) {

  val marshal = new CsMarshal(spec)

  class CsRefs() {
    var cs = mutable.TreeSet[String]()

    def find(ty: TypeRef) { find(ty.resolved) }
    def find(tm: MExpr) {
      tm.args.foreach(find)
      find(tm.base)
    }
    def find(m: Meta) = for(r <- marshal.references(m)) r match {
      case ImportRef(arg) => cs.add(arg)
      case _ =>
    }
  }

  def createCsFile(origin: String, ident: Ident, refs: Iterable[String], f: IndentWriter => Unit) {
    createFile(spec.csOutFolder.get, idCs.ty(ident) + ".cs", (w: IndentWriter) => {
      w.wl("// AUTOGENERATED FILE - DO NOT MODIFY!")
      w.wl("// This file generated by Djinni from " + origin)
      w.wl
      if (refs.nonEmpty) {
        refs.foreach(s => w.wl(s"using $s;"))
        w.wl
      }
      wrapNamespace(w, spec.csNamespace, f)
    })
  }

  override def generateEnum(origin: String, ident: Ident, doc: Doc, e: Enum) {
    val refs = new CsRefs()

    createCsFile(origin, ident, refs.cs, w => {
      writeDoc(w, doc)
      w.w(s"public enum ${marshal.typename(ident, e)}:int").braced {
        for (o <- e.options) {
          writeDoc(w, o.doc)
          w.wl(idCs.enum(o.ident.name) + ",")
        }
      }
    })
  }

  def generateCsConstants(w: IndentWriter, consts: Seq[Const]): Unit = {
    w.wl(s"// TODO generate constants")
  }

  override def generateRecord(origin: String, ident: Ident, doc: Doc, params: Seq[TypeParam], r: Record) {
    val refs = new CsRefs()
    r.fields.foreach(f => refs.find(f.ty))

    val self = marshal.typename(ident, r)

    createCsFile(origin, ident, refs.cs, w => {
      writeDoc(w, doc)

      w.w(s"public class $self").braced {
        w.wl
        generateCsConstants(w, r.consts)
        // Properties.
        for (f <- r.fields) {
          w.wl
          w.wl(s"public ${marshal.fieldType(f.ty)} ${idCs.property(f.ident)} { get; }")
        }

        // Constructor.
        w.wl
        w.wl(s"public $self(").nestedN(2) {
          val skipFirst = SkipFirst()
          for (f <- r.fields) {
            skipFirst { w.wl(",") }
            w.w(marshal.typename(f.ty) + " " + idCs.local(f.ident))
          }
          w.wl(") {")
        }
        w.nested {
          for (f <- r.fields) {
            w.wl(s"${idCs.property(f.ident)} = ${idCs.local(f.ident)};")
          }
        }
        w.wl("}")

        w.wl
        w.wl(s"// TODO deriving types! (Eq)")

        w.wl
        w.w(s"""public override string ToString() => $$"${self}[""")
        val skipFirst = SkipFirst()
        for (f <- r.fields) {
          val name = idCs.property(f.ident)
          skipFirst { w.w(", ") }
          w.w(s"${name}={${name}}")
        }
        w.wl(s"""]";""")

        w.wl
        w.wl(s"// TODO deriving types! (Ord)")
      }
    })
  }

  override def generateInterface(origin: String, ident: Ident, doc: Doc, typeParams: Seq[TypeParam], i: Interface) {
    val refs = new CsRefs()

    if (i.ext.cpp) return 

    createCsFile(origin, ident, refs.cs, w => {
      val self = marshal.typename(ident, i)
      writeDoc(w, doc)

      w.w(s"public abstract class $self").braced {
        generateCsConstants(w, i.consts)

        for (m <- i.methods if !m.static) {
          w.wl
          writeDoc(w, m.doc)
          val ret = marshal.returnType(m.ret)
          val params = m.params.map(p => {
            marshal.paramType(p.ty) + " " + idCs.local(p.ident)
          })
          w.wl("public abstract " + ret + " " + idCs.method(m.ident) + params.mkString("(", ", ", ");"))
        }
        for (m <- i.methods if m.static) {
          w.wl
          writeDoc(w, m.doc)
          val ret = marshal.returnType(m.ret)
          val params = m.params.map(p => {
            marshal.paramType(p.ty) + " " + idCs.local(p.ident)
          })
          w.wl("public static "+ ret + " " + idCs.method(m.ident) + params.mkString("(", ", ", ")") + ";")
        }
      }
    })

    // TODO
  }
}
